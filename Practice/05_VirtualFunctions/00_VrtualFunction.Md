âœ… 1. What is a virtual function in C++?
=================================================
ðŸ”¹Answer:
A virtual function is a member function declared with the virtual keyword in a base class and meant to be overridden in derived classes. It enables runtime polymorphism, allowing function calls to be resolved dynamically using the vtable mechanism.

âœ… 2. What is a vtable and vptr? How are they related to virtual functions?
==============================================================================
ðŸ”¹Answer:
vtable (Virtual Table):
     A compiler-generated table of function pointers for virtual functions in a class.

vptr:
     A hidden pointer in every object of a class with virtual functions. It points to the class's vtable.

When a virtual function is called via a base class pointer/reference, the vptr guides the call to the correct function from the vtable â€” enabling dynamic dispatch.

âœ… 3. How does the compiler generate vtable and vptr?
=======================================================================================
ðŸ”¹Answer:
At compile time:
    01. A vtable is created for each class with virtual functions.
    02. Every object of such a class includes a hidden vptr set at construction to
        point to the classâ€™s vtable.
    03. During a virtual call, the compiler generates code to:
        Fetch the vptr.
        Index into the vtable.
        Call the function pointer.

âœ… 4. Can a constructor be virtual? If not, why?
=======================================================================================
ðŸ”¹Answer:
        No, a constructor cannot be virtual.

ðŸ”¹Reason:
            Constructors initialize the vptr itself.

At the time of base class constructor execution, the derived class part isnâ€™t yet constructed â€” so calling virtual methods may lead to undefined behavior.

However, destructors should be virtual if the class is meant to be base class for polymorphic deletion.

âœ… 5. What happens if a base class has a non-virtual destructor?
=======================================================================================
ðŸ”¹Answer:
If a base class has a non-virtual destructor, deleting a derived object via a base class pointer leads to undefined behavior. Only the base destructor is called â€” the derived destructor is skipped, potentially causing resource leaks.

#include<iostream>
using namespace std;
struct Base {

public:
    Base() {
        
        cout<<"In base class constructor"<<endl;
    }
  ~Base(){
     
     cout<<"In base class destructore"<<endl;
 }
};

struct Derived : Base {
    int* data;
    Derived() : data(new int[100]) {
        cout<<"In derived class constructor"<<endl;
        
    }
    ~Derived() { 
        
        cout<<"In derived class destructore"<<endl;
        delete[] data;
        }
};

int main() {
    Base* obj = new Derived();
    delete obj;
    
   // Derived* d1 = new Base();
    //delete d1;
    
    return 0;
}

output
=============
In base class constructor
In derived class constructor
In base class destructore

ðŸ”¹Fix:
Declare destructors as virtual in polymorphic base classes

âœ… 6. Can virtual functions be static?
====================================================================================
ðŸ”¹Answer:
No. static functions are not tied to an instance (no this pointer) and are resolved at compile time. virtual implies dynamic dispatch based on objectâ€™s runtime type â€” which contradicts static

âœ… 7. What is pure virtual function and abstract class?
====================================================================================
ðŸ”¹Answer:
A pure virtual function is declared like this:

virtual void f() = 0;


01. A class containing at least one pure virtual function is an abstract class.
02. Objects of abstract classes cannot be instantiated.
03. Must be overridden in derived classes unless derived is also abstract.

âœ… 8. Can you override a non-virtual function?
===================================================================================
ðŸ”¹Answer:
Yes, syntactically â€” but it doesnâ€™t behave polymorphically.

class Base { void foo(); };
class Derived : public Base { void foo(); }; // This hides, not overrides

To ensure override behavior, base function must be virtual.

âœ… 9. How does dynamic dispatch work under the hood?
=======================================================================================

Base* b = new Derived();
b->func(); // dynamic dispatch


Internally:
    01. b points to Derived object.
    02. b->vptr points to Derivedâ€™s vtable.
    03. The function pointer in the vtable is resolved at runtime and invoked.

âœ… 10. Can destructors be pure virtual? If yes, how is it useful?
=======================================================================================
ðŸ”¹Answer:
Yes. A pure virtual destructor can enforce abstract behavior:

class Base {
public:
    virtual ~Base() = 0; // pure virtual destructor
};
Base::~Base() { /* must provide definition */ }


This forces the class to be abstract while still allowing proper destruction.

âœ… 11. How can you ensure overriding is correct at compile time?
======================================================================================

ðŸ”¹Answer:
Use the override keyword:

class Base { virtual void foo(); };
class Derived : public Base {
    void foo() override;  // ensures signature matches
};
The compiler throws an error if foo() is incorrectly overridden (e.g., wrong signature).

âœ… 12. Can virtual functions be overloaded?
=======================================================================================
ðŸ”¹Answer:
Yes. You can have multiple functions with the same name but different signatures â€” virtual or not.

class A {
public:
    virtual void foo();
    virtual void foo(int);
};


Overloading works with different parameter lists. But note: overloading and overriding are different concepts.

âœ… 13. Virtual function call inside constructor/destructor â€” what's the behavior?
=======================================================================================
ðŸ”¹Answer:
In constructors and destructors, virtual dispatch is disabled â€” calls are resolved using the current class's version, not derived.

ðŸ”¹Why?
Because the object is not fully constructed or has begun destruction.

âœ… 14. How do you disable virtual dispatch explicitly?
=======================================================================================
ðŸ”¹Answer:
You can call the function using scope resolution:

b->Base::func(); // calls base version, not virtual





âœ… 1. Memory Layout Diagram (vptr + vtable)
=======================================================================================
class Base {
public:
    virtual void show() { std::cout << "Base\n"; }
    virtual ~Base() {}
};

class Derived : public Base {
public:
    void show() override { std::cout << "Derived\n"; }
    virtual void onlyInDerived() { std::cout << "Derived only\n"; }
};


ðŸ§  Object Memory Layout (simplified)
------------------------------------------
Assuming :
            Derived obj;

-------------------------
| vptr (points to vtable)|
-------------------------
|        Base members   |
-------------------------
|      Derived members  |
-------------------------


ðŸ§  Derived's vtable (simplified layout)
----------------------------------------
Derived_vtable:
+----------------------------+
| &Derived::show             |  // overrides Base::show
| &Derived::~Derived         |  // destructor
| &Derived::onlyInDerived    |  // own virtual
+----------------------------+


Base classâ€™s vtable would only contain:
----------------------------------------------
Base_vtable:
+----------------------------+
| &Base::show                |
| &Base::~Base               |
+----------------------------+


vptr inside the object points to the correct vtable at runtime â€” enabling dynamic dispatch.

